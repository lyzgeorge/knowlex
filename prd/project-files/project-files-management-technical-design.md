# Project Files Management — Technical Design

This document translates the PRD “项目文件管理功能 PRD” into a concrete, implementation-aligned technical design for the Electron + React (renderer) + Node (main) architecture of Knowlex.

DRY/SPOT Alignment
- DRY (Don’t Repeat Yourself): Reuse existing services, utilities, IPC wrappers, and UI patterns. Avoid duplicating validation, model resolution, or parsing logic.
- SPOT (Single Point Of Truth): Centralize constraints, IPC channel names, prompts, and schema definitions in shared or dedicated modules. A new dedicated module at `@shared/constants/project-files.ts` will contain all project-file specific parameters (limits, chunk sizes, storage paths) to prevent drift.

Goals:
- Persist and manage project-scoped files (distinct from transient chat attachments).
- Parse and store file content and metadata synchronously upon upload.
- Generate Smart Notes asynchronously with robust, resumable processing.
- Provide a two-pane detail view with editable Smart Notes and Markdown content.
- Integrate with settings to select a file-processing model and token limits.

Non‑Goals:
- Full‑text vector search/indexing for project files (future work).
- Cross‑project file sharing or attachment migration.
- Cloud sync of raw files.

## Architecture Overview

- Renderer
  - Project page shows a grid of project files below `ChatInputBox`.
  - File detail modal with tabs (Metadata, Smart Notes) and a right markdown editor (or image preview).
  - New store for project files (list, upload, delete, update content/notes, regenerate notes).

- Main (Electron)
  - Project file service: orchestrates validation, storage, parsing, DB persistence, and open-with-system.
  - Smart Notes worker/queue: performs asynchronous AI analysis with chunking for large content.
  - IPC handlers: `projectFile:*` channels for CRUD and actions.

- Shared
  - DB schema and queries for `project_files`.
  - Reuse file parsing utilities (`@main/services/file-parser.ts`).
  - Reuse validation utilities (`@shared/utils/validation.ts`).
  - Reuse MIME/type constants and image checks.

## Data Model

Table: `project_files`

- `id` TEXT PRIMARY KEY (generated by `@shared/utils/id`)
- `project_id` TEXT NOT NULL REFERENCES `projects(id)` ON DELETE CASCADE
- `filename` TEXT NOT NULL (sanitized, original name also stored in metadata)
- `file_size` INTEGER NOT NULL
- `file_hash` TEXT NOT NULL (MD5 of file bytes)
- `file_path` TEXT NOT NULL (relative path to local file from userData root)
- `upload_time` TEXT NOT NULL DEFAULT `datetime('now')`
- `content_path` TEXT NULL (relative path to parsed textual content file, NULL for images)
- `mime_type` TEXT NOT NULL
- `smart_notes` TEXT NULL (JSON blob with `summary`, `abstract`, `keywords`, `structure`)
- `smart_notes_status` TEXT NOT NULL CHECK IN ('pending', 'processing', 'completed', 'failed') DEFAULT 'pending'
- `smart_notes_generated_at` TEXT NULL
- `smart_notes_schema_version` TEXT NOT NULL DEFAULT '1.0' (Schema version for forward compatibility)
- `error` TEXT NULL (last processing error, if any)
- `created_at` TEXT NOT NULL DEFAULT `datetime('now')`
- `updated_at` TEXT NOT NULL DEFAULT `datetime('now')` (auto-updated via triggers)

Indexes
- `idx_project_files_project_id` on `(project_id, updated_at DESC)`
- `idx_project_files_status` on `(smart_notes_status)`

Triggers
- Auto-update `updated_at` on record modifications

SPOT: Schema & Queries
- Define the entity schema in `@main/database/schemas.ts` using `DatabaseEntity` for CRUD.
- Add typed query functions in `@main/database/queries.ts` delegating to `DatabaseEntity`.
- Keep any raw SQL localized to `queries.ts` only (e.g., pagination), never in services.

Smart Notes JSON Schema v1.1 (business fields only; no separate `structure`; serialized in `smart_notes`):
```
{
  "summary": "One-sentence summary",
  "abstract": "5W1H/IRAC-structured paragraph(s)",
  "keywords": ["keyword1", "keyword2"],
  "chunks": [
    { "id": 1, "lines": [1, 2, 3] },
    { "id": 2, "lines": [4, 5] }
  ]
}
```

**Schema Version Management**:
- Current version: 1.1 (stored in `smart_notes_schema_version`)
- Future extensibility: System can handle schema upgrades (e.g., adding `sentiment`, `topics`)
- Future-Proofing: The version field allows for future schema evolution. If the schema changes, this field will enable a clear and safe upgrade path for existing data.

**External Content Storage Strategy**:
- **Text files only（统一策略）**: 仅“文本型可解析”文件（PDF、Office、纯文本、代码等）生成 `content.txt`。
- **Images/binary stored as-is**: 图片/其他二进制类型不生成 `content.txt`，预览直接读取原始文件；Renderer 通过 `content_path === null` 统一分支处理。
- **Database contains relative paths**: All paths relative to userData directory for portability
- **Performance benefits**:
  - Eliminates database bloat from large content
  - Reduces memory pressure during content operations
  - Enables future content versioning for text files
- **Path portability**: Relative paths ensure app works after directory moves/migrations

Notes
- `structure` may be an empty string if no clear hierarchy is found.
- `content_path` 指向文本型文件的解析内容；对于图片/二进制类型为 NULL。Renderer 基于是否为空决定编辑器/预览渲染。
- `file_path` points to original uploaded file with preserved extension
- All paths relative to userData directory; resolved at runtime for portability

## Storage Layout

**Decoupled Storage Structure** (recommended for robustness):
- Base directory: `app.getPath('userData')/files`
- Per project: `.../files/<projectId>/`
- Per file: `.../files/<projectId>/<fileId>/`
  - `original.<ext>` (original uploaded file with preserved extension, e.g., `original.pdf`, `original.docx`)
  - `content.txt` (content representation - textual for documents only, images have no content.txt)
- **Benefits**:
  - Complete decoupling from user-provided filenames eliminates edge cases
  - Each file gets isolated namespace for all related assets
  - Preserved file extensions enable proper system opening behavior
  - Future-proof for thumbnails, versions, metadata etc.
- MD5 hash stored in `file_hash` for integrity checks and deduplication.

**Content Representation Strategy**:
- **Text-based files** (PDF, DOC, TXT, etc.): `content.txt` contains extracted plain text
- **Images**: No `content.txt`, preview displays original file directly
- **Content-aware processing**: Only text files get Smart Notes generation
- **Simplified architecture**: Eliminates JSON metadata complexity for non-text files
- **Future extensibility**: OCR can be added later by generating `content.txt` for images

Path Safety
- Use `sanitizeFilename` (`@shared/utils/validation.ts`) and validate that the resolved path is inside the base directory to prevent path traversal.
- Only open paths with `shell.openPath(file_path)` after existence and readability checks.

SPOT: Storage Root Helper
- Provide a single helper (e.g., `getProjectFilesRoot()` in `@main/utils/paths.ts`) to resolve `app.getPath('userData')/files` and perform safe joins. All IO uses this helper. The base path segment (`files`) should be defined in the dedicated constants module `@shared/constants/project-files.ts`.

## Validation & Constraints

- File type: reuse `SUPPORTED_FILE_TYPES` from `@shared/constants/file.ts`.
- Project constraints: single file ≤ 50MB and ≤ 100 files per project.
  - SPOT: Define `PROJECT_FILE_CONSTRAINTS` in `@shared/constants/project-files.ts` (do not change existing attachment `FILE_CONSTRAINTS`).
  - DRY: Add `validateProjectFileConstraints()` in `@shared/utils/validation.ts` (or extend `validateFileConstraints(files, context)`), used by both Renderer (UX pre-check) and Main (authoritative check).
  - Renderer should show current usage `(uploaded/limit)` via a single derived selector.
- Enforce limits at both renderer (pre-check UX) and main (authoritative check) using shared helpers.

## Parsing Strategy

Parsers (reuse existing):
- Office: `officeparser` via `OfficeParser` (docx/xlsx/pptx/odt/odp/ods)
- PDF: `pdfjs-dist` via `PDFParser`
- Plain text/code: `PlainTextParser`
- Images: treat as image; produce preview data URL and basic metadata (no OCR in scope)

Memory Protection
- For very large files, rely on `pdfjs-dist`/`officeparser` library behavior and wrap with size checks before reading buffers.
- Consider introducing a parser-level guard (read as stream or chunked) if library behavior leads to memory spikes. Emit clear errors and mark as `failed` if extraction is not feasible.

## Smart Notes Generation (Async)

Background Worker/Queue
- Dedicated main-process module `SmartNotesWorker` with a single-concurrency queue (FIFO) to process pending files.
- **Simple Queue Management**: Basic FIFO queue with task deduplication for the same file ID.
- **Durability**: The queue's state is durable as it is derived from the `smart_notes_status` field in the `project_files` database table. On application start, the worker queries for files in `pending` or `processing` states to resume its work, ensuring no tasks are lost.
- **Observability**: All stages within the worker (queueing, deduplication, resumption, chunking, agent invocation, success, failure) will be logged using a structured logger. Each log entry must include the `fileId` and `projectId` to allow for complete, traceable diagnostics of a single task.
- Queue triggers: after upload, on app start (resume `pending`/`processing`), and on user `Regenerate`.
- Status lifecycle: `pending → processing → completed | failed` with timestamps and error details.

Resumption, Idempotency, and Retry（新增）
- Startup resumption: On app start, scan `pending` and `processing`. Any `processing` tasks whose last update exceeds a timeout threshold (e.g., 30 minutes) are marked back to `pending` and re-enqueued to handle crash recovery.
- Deduplication: Ensure only one active/enqueued task per `fileId` at any time.
- Retry & backoff: For transient AI or parsing failures, retry up to a maximum count (e.g., 3) with exponential backoff. Persist the last error in `error` and update `smart_notes_status` accordingly on terminal failure.
- Regenerate behavior: A user-triggered regenerate resets `error`, sets status to `pending`, and replaces any in-flight task with a fresh one.

-Model Resolution
- Add Settings keys:
  - `fileProcessingModelId: string | null` — model config ID for Smart Notes; when null, fall back to default chat model.
  - `fileMaxInputTokens: number` — default 131072 (128K) configurable token limit for chunking.
- SPOT: Defer model resolution to `openai-adapter` and its `ai-params` helpers (explicit → conversation → user default). Do not reimplement resolution logic inside the worker.

Input Preprocessing (Line Tagging)
- Before invoking the Smart Notes agent, preprocess text content:
  - Escape any '<' and '>' in user content to `&lt;` and `&gt;` to avoid tag conflicts.
  - Wrap each original line (1-based) as `<1>...</1>`, `<2>...</2>`, etc. Keep whitespace intact.
  - Do not modify the content other than the angle bracket escaping.
  - The agent prompt instructs the model to return only: `summary`, `abstract`, `keywords`, and semantic groupings as a JSON `chunks` array (no separate `structure`). Chunks group adjacent line numbers into ~500-token segments based on semantic coherence.

Chunking for Large Content
- Use `getEncodingForModel` + `countTextTokens` to count tokens on `content`.
- If tokens ≤ limit: single pass.
- If tokens > limit: iterative passes of 30K tokens with 2K overlap per PRD.
  - First pass uses a base prompt that requests summary, abstract, keywords, and chunks only (no `structure`).
  - Subsequent passes use an iterative prompt with current aggregated result injected using explicit placeholders: `{previous_summary}`, `{previous_abstract}`, `{previous_keywords}`, `{previous_chunks}`.
  - Merge strategy: The result from each iterative pass completely replaces the previous result. The iterative prompt is designed to produce a progressively refined, holistic analysis. Therefore, the output from the final chunk is considered the definitive Smart Note, requiring no complex merging logic.

SPOT: Chunking Constants
- Define `FILE_SMART_NOTES_CHUNK_SIZE_TOKENS = 30000` and `FILE_SMART_NOTES_OVERLAP_TOKENS = 2000` in `@shared/constants/project-files.ts`, referenced by the worker and tests.

SPOT: Centralized Constants & Types（新增）
- Centralize file limits, chunk sizes, timeouts, storage roots, and schema versions in `@shared/constants/project-files.ts`.
- Define `ProjectFileRow` and Smart Notes v1.1 (including `chunks`) types in `@shared/types` to keep main/renderer in lockstep.

## IPC API Surface

Renderer → Main (request/response IPC)
- `projectFile:upload`
  - Input: `{ projectId: string, files: Array<{ name: string, path?: string, contentBase64?: string, size: number }> }`
  - Behavior: Validate constraints. **Idempotency Check**: Before processing, it checks if a file with the same `file_hash` already exists for the given `projectId`. If a duplicate is found, the upload is rejected with an appropriate error, and a notification is sent to the user. Otherwise, it persists the raw file to storage, parses content, inserts a DB row, enqueues Smart Notes generation, and returns the created `ProjectFile` row.
- `projectFile:list`
  - Input: `{ projectId: string }`
  - Output: `{ items: ProjectFileRow[] }` (simple list sorted by updated_at DESC)
- `projectFile:get`
  - Input: `{ id: string }`; Output: full row with content read from `content_path` file and `smart_notes`.
- `projectFile:updateContent`
  - Input: `{ id: string, content: string }`; updates markdown text field.
- `projectFile:updateSmartNotes`
  - Input: `{ id: string, smartNotes: SmartNotesJson }`; sanitize keywords, update JSON and timestamps.
- `projectFile:regenerateSmartNotes`
  - Input: `{ id: string }`; sets status and enqueues.
- `projectFile:delete`
  - Input: `{ id: string }`; removes DB row and deletes raw file from storage.
- `projectFile:open`
  - Input: `{ id: string }`; secure open via `shell.openPath(file_path)` after path validation.

Main → Renderer (events)
- `projectFile:statusUpdate` — payload `{ id, status, error?, generatedAt? }` for live status updates on Smart Notes generation（首版不包含精确队列位次与等待时间）。
- `projectFile:created`/`updated`/`deleted` — keep list views in sync without polling.

SPOT: IPC Types & Channels
- Define request/response interfaces and channel name constants in `@shared/types/ipc.ts` and/or `@shared/constants/events.ts` (e.g., `PROJECT_FILE_CHANNELS`, `PROJECT_FILE_EVENTS`).
- Use `handleIPCCall` and `validateRequest` for all handlers to keep error handling and input validation consistent.

## Renderer Components

- Project Files Grid (below `ChatInputBox` on ProjectPage)
  - Reuse `AttachmentCard` styles; provide project-file flavor with additional actions (open, delete, details).
  - Show count `(N/100)` and an upload button.
  - Paginate and optionally filter/sort when count > 20.

- File Detail Modal
  - Left tabs: Metadata (read-only) and Smart Notes (editable fields, status, timestamps, regenerate button).
  - **Status Display**: Show basic processing status and last generation time.
  - Right panel: `@uiw/react-md-editor` for markdown content; XSS-safe render with HTML whitelist.
  - For images: show preview image instead of editor; disable `updateContent`.
  - Save buttons for both sides; disable during Smart Notes `processing`.

- State Management (Zustand)
  - `useProjectFileStore` with actions:
    - `fetch(projectId)`, `upload(files)`, `delete(id)`, `open(id)`
    - `get(id)`, `updateContent(id, content)`, `updateSmartNotes(id, smartNotes)`
    - `regenerate(id)` and event subscriptions to reflect status.
    - **Status management**: Subscribe to `projectFile:statusUpdate` events for status changes.
  - DRY: Keep all `window.knowlex` calls in one store data adapter (like `@renderer/stores/conversation/data.ts`) and reuse notifications utilities.

## Main Process Services

The service layer will introduce a new, Agent-based framework for structured data generation, orchestrated by the `SmartNotesWorker`.

### Agent Architecture (New)

To provide a unified, robust, and extensible framework for structured data extraction, we will implement a lightweight Agent architecture. This design ensures that Agents remain atomic and pure (single input → single output), making them highly reusable for future tasks. This agent-based approach is also future-proof: while the initial implementation uses a single `generateObject` call, the `AgentRunner` can be extended to support more complex, multi-step agentic workflows (e.g., tool use) without altering the core design.

- **`@main/services/agent-runner.ts` (New)**: A generic, stateless runner for executing Agent tasks.
  - **Unified Entrypoint**: It encapsulates the logic for model resolution (reusing `modelConfigService` + `resolveModelContext`), message construction, and calling the AI SDK's `generateObject` function.
  - **Guaranteed Structured Output**: By leveraging `generateObject` with a Zod schema, it ensures the AI model's response is always a valid, type-safe JSON object. It will return a typed result on success or a structured error on failure. The structured error will contain the original raw text from the model for improved diagnostics.

- **`@main/services/agents/smart-notes-agent.ts` (New)**: A dedicated agent for the Smart Notes generation task, located in a new `agents` subdirectory.
  - **Business Logic**: It imports the necessary prompt and schema from the shared definitions.
  - **Exports High-Level Function**: It exports a simple function, `generateSmartNotes(content, runOptions)`, which uses the `AgentRunner` internally. This provides a clean, high-level API to the rest of the application.

- **`@shared/ai/agents/` (New Directory)**: This new directory will serve as the Single Point of Truth (SPOT) for all Agent definitions.
  - **`smart-notes.definition.ts`**: Exports `SMART_NOTES_SYSTEM_PROMPT`, `SmartNotesSchema` (Zod), and helpers. The prompt consumes content formatted as `<行号>内容</行号>` with `&lt;`/`&gt;`-escaped angle brackets, and requires returning only `summary`, `abstract`, `keywords`, and `chunks` (array of `{id, lines[]}` grouping adjacent line numbers into ~500-token semantic segments). There is no separate `structure` field. The agent is executed via `generateObject` to guarantee schema-conformant JSON validated by Zod.

### SmartNotesWorker (Role: Orchestrator)

The `SmartNotesWorker`'s sole responsibility is to orchestrate the asynchronous lifecycle of a Smart Notes generation task. It does not contain any AI interaction logic itself.

- **Core Workflow**:
  1.  Fetches a pending file task from the queue.
  2.  Updates the file's status to `processing`.
  3.  Reads the file content from `content_path`.
  4.  **Handles Chunking**:
      - It uses the `countTextTokens` function from the existing `@shared/utils/token-count.ts` to determine if the content exceeds the `fileMaxInputTokens` limit from settings.
      - If chunking is required, the logic for splitting text (e.g., 30k tokens per chunk with a 2k overlap) resides entirely within the worker.
  5.  **Iteratively Calls Agent**:
      - For the first chunk, it calls `generateSmartNotes(chunk1, { modelConfigId })`.
      - For subsequent chunks, the worker constructs an iterative prompt (including the previous result) and calls `generateSmartNotes` again, using the new result to overwrite the previous one.
  6.  **Persists Result**: After all chunks are processed, the final `SmartNotes` object is saved to the database, and the status is set to `completed`.
  7.  **Handles Errors**: It wraps agent calls. For transient errors (e.g., network issues, model availability), it will employ a retry strategy with exponential backoff (e.g., 3 attempts). If all retries fail, it logs the structured error from the AgentRunner and updates the file's status to `failed`.

### ProjectFileService (Role Unchanged)

The `ProjectFileService` remains responsible for the primary file lifecycle events (upload, delete, open, content updates) and database interactions, but it will now enqueue a task for the `SmartNotesWorker` upon a successful new file upload.

## Settings Integration

- UI: Settings → Models: add “File Processing Model” selector and “File Token Limit” numeric input.
- Storage: use `app_settings` table with keys `fileProcessingModelId` and `fileMaxInputTokens` (default 131072).
- Resolution: when unset, fallback to default chat model (existing default model config).
 - SPOT: Access via `settingsService` (`@main/services/settings.ts`); never read env directly in feature code.

## Error Handling Strategy

**Unified Error Handling** (reusing existing patterns from `@main/utils/error.ts`):
- **File Operations**: Use `formatUnknownError` for file I/O errors (read, write, delete)
- **Processing Errors**: Use `processingErrorMessage` for file parsing and content extraction failures
- **Critical System Errors**: Use `criticalErrorMessage` for database or storage system failures
- **IPC Error Boundaries**: All IPC handlers use `handleIPCCall` wrapper for consistent error formatting
- **Validation Errors**: Leverage `ValidationPatterns` and `ErrorMessages` from `@main/ipc/common.ts`
- **AI Processing Errors**: Reuse patterns from `@main/services/ai-retry.ts` for model communication failures.

**Error Context Enhancement**:
- File-specific errors include filename and operation type
- Smart Notes errors include processing stage (tokenization, generation, validation)
- Storage errors include full path context (with safety checks)
- All errors are logged with appropriate severity levels

**Graceful Degradation**:
- File parsing failures: retain original file, mark content as unavailable
- Smart Notes generation failures: preserve file and parsed content, allow manual retry
- Storage quota exceeded: clear error messages with cleanup suggestions

## Security Considerations

- Filename sanitization and path whitelisting for all IO.
- XSS-safe markdown rendering with HTML whitelist in `@uiw/react-md-editor` preview.
- Validate IPC inputs with shape guards; all DB and FS operations are parameterized.
- Do not follow symlinks into storage; only write into storage root.
- Limit large files; enforce memory thresholds and bail out gracefully with clear errors.

## Performance Considerations

- Simple list display sorted by updated_at DESC.
- **Basic status display**: Show processing status and last generation time.
- Avoid large `content` payloads over IPC on list endpoints; fetch full content on `get(id)`.
- Cache token encoding (`getEncodingForModel`) across worker jobs.
- **Task deduplication**: Prevent multiple queue entries for same file.
- DRY: Use a single selector to derive summaries/snippets/status for list items rather than recomputing in multiple components.

## Error Handling & UX

- Upload: show per-file validation errors; continue processing valid files.
- Parsing: if content extraction yields empty string, mark as `failed` with explanatory error.
- Smart Notes: show `processing/completed/failed` with last generated time; disable save/regenerate while `processing`.
- Regenerate: keeps file and content; only re-computes Smart Notes.
- Delete: irreversible; confirm dialog.

## Migrations Plan

1) Add `project_files` table + indexes + triggers in `@main/database/migrations.ts` (new migration).
2) Add schema entity in `@main/database/schemas.ts` and CRUD in `@main/database/queries.ts`.
3) Register IPC handlers in `@main/ipc/project-file.ts` and wire in app bootstrap using `handleIPCCall`.
4) Expose `window.knowlex.projectFile` APIs in `@main/preload.ts` under a single namespace; add type-safe wrappers.
5) Implement `ProjectFileService` and `SmartNotesWorker` in `@main/services/`.
6) Add renderer store `@renderer/stores/project-file.ts` and components (`ProjectFileGrid`, `ProjectFileModal`).
7) Integrate on `ProjectPage` beneath `ChatInputBox`.
8) Settings panel fields and persistence hook-up via `settingsService`.

## Testing Strategy

- Unit tests
  - Validation and sanitization (filenames, constraints, keyword normalization).
  - Worker chunking logic and merge behavior (with mocked adapter).
  - IPC input validation for each channel.

- Integration tests
  - Upload → parse → DB persist → worker enqueues path.
  - Regenerate flow updates status and timestamps.
  - Delete removes file from disk and DB.

- Manual QA
  - Large file (> token limit) incremental Smart Notes generation.
  - Image upload shows preview; content editor disabled.
  - “Open file” opens via OS; non-existent path shows error.

## Architecture Decisions

**Content Storage Strategy** (resolved):
- **Decision**: Only text files get external `content.txt` storage, database contains relative paths
- **Rationale**: Prevents database bloat, reduces memory pressure, eliminates JSON complexity for images
- **Trade-off**: Slightly more complex file I/O vs. significant scalability gains

**Non-text File Content Strategy** (resolved):
- **Decision**: Images and non-text files stored as original files only, no `content.txt`
- **Rationale**: Simplifies architecture, reduces storage overhead, eliminates JSON complexity
- **Preview Strategy**: Images displayed directly from original file, no preprocessing needed

**Content Update Policy** (resolved):
- **Decision**: User edits affect only `content.txt`, original files remain immutable
- **Rationale**: Reverse-engineering edits back to PDFs/DOCXs is technically impractical
- **UX Implication**: UI must clearly indicate when content diverges from original parsing

**Storage Path Strategy** (resolved):
- **Decision**: Completely decoupled directory structure with relative paths from userData
- **Rationale**: Eliminates filename edge cases, provides isolated namespaces, ensures portability
- **Path Management**: Store relative paths, resolve to absolute at runtime for cross-platform compatibility

## Implementation Notes

- FILE_CONSTRAINTS vs PROJECT_FILE_CONSTRAINTS: adopt dedicated constraints to honor PRD (50MB & 100 files) without altering chat attachments (10MB today).
- Keyword cap: set a UI cap (e.g., 32) to keep Smart Notes manageable.
- Resume policy: on app start, move lingering `processing` to `pending` before enqueueing to avoid partial state ambiguity.
- Task deduplication: Same file ID can only have one queue entry; subsequent regenerate requests replace existing queue item.
- Database triggers: Auto-update `updated_at` timestamp on record modifications.

## Implementation Notes & References

- **Reuse**:
  - Types/constants from `@shared/constants/` and `@shared/utils/`.
  - File parsing logic from `@main/services/file-parser.ts`.
  - Token counting for chunking from `@shared/utils/token-count.ts`.
  - Existing model resolution logic, which will be integrated into `@main/services/agent-runner.ts`.

- **New Files (Illustrative)**:
  - `@main/services/agent-runner.ts`
  - `@main/services/agents/smart-notes-agent.ts`
  - `@main/services/SmartNotesWorker.ts`
  - `@shared/ai/agents/smart-notes.definition.ts`
  - `@shared/types/smart-notes.d.ts` (or similar for shared UI types)
  - Other files for this feature remain as previously planned (IPC, renderer components, etc.).

- **IPC Namespacing**:
  - `projectFile:*` will be used to avoid confusion with the existing ephemeral `attachment:*` channels.

This design aligns with the PRD while integrating cleanly into existing parsing, validation, and IPC patterns in the codebase. It scopes new functionality to project assets, ensures asynchronous AI processing with robust failure handling, and provides a clear path to implementation with minimal disruption.
- All IPC responses use `IPCResult<T>` for consistency.
